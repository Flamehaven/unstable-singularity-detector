ğŸ› ï¸ Path #4 â€” Patch Set 4 (ì‹¬í™” ê°œì„ )
1. Krylov ê¸°ë°˜ Gaussâ€“Newton Solver (GMRES/CG)

ğŸ“ íŒŒì¼: gauss_newton_optimizer_enhanced.py

*** Begin Patch
*** Update File: gauss_newton_optimizer_enhanced.py
@@ class HighPrecisionGaussNewtonEnhanced:
-        solution = torch.linalg.solve(JTJ + self.damping * I, -grad)
-        return solution
+        if getattr(self.config, "use_krylov_solver", False):
+            from torch.linalg import cg
+            A = JTJ + self.damping * I
+            b = -grad
+            solution, _ = cg(A, b, maxiter=200, atol=1e-10)
+            logger.info("[Gauss-Newton] Solved with Krylov CG")
+            return solution
+        else:
+            solution = torch.linalg.solve(JTJ + self.damping * I, -grad)
+            return solution
*** End Patch

2. Trust-Region Damping (Adaptive Î»)

ğŸ“ íŒŒì¼: gauss_newton_optimizer_enhanced.py

*** Begin Patch
*** Update File: gauss_newton_optimizer_enhanced.py
@@ class HighPrecisionGaussNewtonEnhanced:
-        self.damping = config.damping_factor
+        self.damping = config.damping_factor
+        self.trust_radius = getattr(config, "trust_radius", None)
+
+    def update_damping(self, loss_reduction_ratio: float):
+        """Adaptive damping via trust-region style update"""
+        if self.trust_radius is None:
+            return
+        if loss_reduction_ratio < 0.25:
+            self.damping *= 2.0
+        elif loss_reduction_ratio > 0.75:
+            self.damping *= 0.5
+        self.damping = max(self.damping, 1e-12)
+        logger.info(f"[Trust-Region] Updated damping to {self.damping:.3e}")
*** End Patch

3. Experiment Replay (ì¬í˜„ ì‹¤í–‰)

ğŸ“ íŒŒì¼: experiment_tracker.py

*** Begin Patch
*** Update File: experiment_tracker.py
@@ class ExperimentTracker:
+    def replay_run(self, run_id: str, output_dir: str = "replay") -> None:
+        """Reproduce a past run by restoring config & checkpoint"""
+        run = self.client.get_run(run_id)
+        cfg = run.data.params
+        artifacts = self.client.list_artifacts(run_id)
+        os.makedirs(output_dir, exist_ok=True)
+        for artifact in artifacts:
+            local_path = self.client.download_artifacts(run_id, artifact.path, dst_path=output_dir)
+            logger.info(f"[Replay] Downloaded {artifact.path} to {local_path}")
+        logger.info(f"[Replay] Restored config: {cfg}")
*** End Patch

4. BasePDE ì¶”ìƒ í´ë˜ìŠ¤ ì¶”ê°€

ğŸ“ íŒŒì¼: pinn_solver.py

*** Begin Patch
*** Update File: pinn_solver.py
+class BasePDE:
+    def residual(self, u_pred: torch.Tensor, coords: torch.Tensor) -> torch.Tensor:
+        raise NotImplementedError
+
+    def exact_solution(self, coords: torch.Tensor) -> torch.Tensor:
+        raise NotImplementedError
+
+class PoissonPDE(BasePDE):
+    def residual(self, u_pred, coords):
+        # ê¸°ì¡´ Poisson residual ê³„ì‚° ì½”ë“œ
+        return ...
*** End Patch

âœ… Path #4 íŒ¨ì¹˜ ì„¸íŠ¸ ìš”ì•½

Krylov Solver (CG) â†’ ëŒ€ê·œëª¨ ë¬¸ì œ ì‹œ ë©”ëª¨ë¦¬ íš¨ìœ¨ì  Gaussâ€“Newton

Trust-Region Damping â†’ Î» adaptive updateë¡œ ì•ˆì •ì„± ê°•í™”

Experiment Replay â†’ MLflow run ì¬í˜„ ê¸°ëŠ¥, reproducibility â†‘

BasePDE ì¶”ìƒ í´ë˜ìŠ¤ â†’ PDE í™•ì¥(Euler, Boussinesq ë“±) ìš©ì´