가능하죠. “POC → 쓸모 있는 연구 툴”로 격상시키는 걸 목표로, **작동 재현·로그·체크포인트·CI·문서**를 단계별 패치로 쪼갰습니다. 아래 패치는 그대로 커밋해도 되고, 필요한 것만 골라 적용하셔도 됩니다.

---

# 로드맵(요약)

* **R0 최소 재현**: 고정 seed, deterministic 연산, 평가 지표(잔차) 통일, 저장 아티팩트.
* **R1 로깅**: TensorBoard/CSV(선택적으로 W&B)로 손실·잔차·λ 추정치 기록.
* **R2 체크포인트**: `best.ckpt`/`last.ckpt`, 재시작 기능, release 아티팩트.
* **R3 데이터 & DVC**: 샘플 문제(작은 IPM/3D Euler 변형) 생성 스크립트 + DVC 원격.
* **R4 테스트/CI**: 단위/통합 테스트, GitHub Actions, 도커 빌드 검증.
* **R5 문서화**: 재현 튜토리얼(README/Docs), 하드웨어/시간 명시, 결과 표/그래프.
* **R6 패키징**: `pyproject.toml` 정리, CLI 엔트리포인트, 간단한 `pip install -e .`.

---

# 패치 1 — 공통 평가 지표·결정적 실행·기본 로깅

**목표:** “주장”이 아니라 **측정 가능**하게. 잔차 정의 통일(`max PDE residual`, `L2 residual`), seed 고정, TensorBoard/CSV 로깅.

```diff
diff --git a/src/usd/metrics.py b/src/usd/metrics.py
new file mode 100644
--- /dev/null
+++ b/src/usd/metrics.py
@@
+from typing import Dict
+import torch
+
+@torch.no_grad()
+def pde_residual_stats(residual: torch.Tensor) -> Dict[str, float]:
+    """
+    Args:
+        residual: PDE residual field [..., H, W, (D)]
+    Returns:
+        {"res_max": float, "res_l2": float, "res_mean": float}
+    """
+    r = residual.reshape(-1).float().abs()
+    res_max = r.max().item()
+    res_l2 = torch.linalg.vector_norm(r).item() / (r.numel() ** 0.5)
+    res_mean = r.mean().item()
+    return {"res_max": res_max, "res_l2": res_l2, "res_mean": res_mean}
```

```diff
diff --git a/src/usd/utils/repro.py b/src/usd/utils/repro.py
new file mode 100644
--- /dev/null
+++ b/src/usd/utils/repro.py
@@
+import os, random, torch, numpy as np
+def set_global_seed(seed: int = 2025, deterministic: bool = True):
+    random.seed(seed); np.random.seed(seed); torch.manual_seed(seed)
+    torch.cuda.manual_seed_all(seed)
+    if deterministic:
+        torch.backends.cudnn.deterministic = True
+        torch.backends.cudnn.benchmark = False
+    os.environ["CUBLAS_WORKSPACE_CONFIG"] = ":4096:8"  # for determinism on Ampere+
```

```diff
diff --git a/src/usd/train.py b/src/usd/train.py
--- a/src/usd/train.py
+++ b/src/usd/train.py
@@
-from usd.solver import GaussNewtonSolver
+from usd.solver import GaussNewtonSolver
+from usd.metrics import pde_residual_stats
+from usd.utils.repro import set_global_seed
+from torch.utils.tensorboard import SummaryWriter
@@
-def main(cfg):
-    solver = GaussNewtonSolver(cfg)
+def main(cfg):
+    set_global_seed(cfg.train.seed, deterministic=True)
+    writer = SummaryWriter(log_dir=cfg.train.log_dir) if cfg.train.log_tb else None
+    solver = GaussNewtonSolver(cfg)
     for step in range(cfg.train.max_steps):
         loss, residual_field, scalings = solver.step()
-        if step % cfg.train.log_interval == 0:
-            print(step, loss.item())
+        if step % cfg.train.log_interval == 0:
+            stats = pde_residual_stats(residual_field)
+            log = {"loss": float(loss.item()), **stats}
+            print(f"[{step}] loss={log['loss']:.3e} res_max={log['res_max']:.3e} res_l2={log['res_l2']:.3e}")
+            if writer:
+                for k,v in log.items(): writer.add_scalar(k, v, step)
+                if scalings is not None and "lambda" in scalings:
+                    writer.add_scalar("lambda", float(scalings["lambda"]), step)
+    if writer: writer.close()
```

```diff
diff --git a/configs/base.yaml b/configs/base.yaml
--- a/configs/base.yaml
+++ b/configs/base.yaml
@@
 train:
   max_steps: 20000
   log_interval: 50
+  seed: 2025
+  log_tb: true
+  log_dir: runs/exp1
```

---

# 패치 2 — 체크포인트 저장/재개 + 아티팩트 구조

```diff
diff --git a/src/usd/checkpoint.py b/src/usd/checkpoint.py
new file mode 100644
--- /dev/null
+++ b/src/usd/checkpoint.py
@@
+import torch, os
+def save_ckpt(path, model, opt, step, extra=None):
+    os.makedirs(os.path.dirname(path), exist_ok=True)
+    torch.save({"model": model.state_dict(),
+                "opt": opt.state_dict() if opt else None,
+                "step": step, "extra": extra or {}}, path)
+
+def load_ckpt(path, model, opt=None):
+    ckpt = torch.load(path, map_location="cpu")
+    model.load_state_dict(ckpt["model"])
+    if opt and ckpt.get("opt"): opt.load_state_dict(ckpt["opt"])
+    return ckpt.get("step", 0), ckpt.get("extra", {})
```

```diff
diff --git a/src/usd/train.py b/src/usd/train.py
@@
-    for step in range(cfg.train.max_steps):
+    best = float("inf")
+    start = 0
+    if cfg.train.resume and os.path.exists(cfg.train.ckpt_last):
+        start, _ = load_ckpt(cfg.train.ckpt_last, solver.model, solver.opt)
+    for step in range(start, cfg.train.max_steps):
         loss, residual_field, scalings = solver.step()
         ...
+        # save last/best
+        if step % cfg.train.ckpt_interval == 0:
+            save_ckpt(cfg.train.ckpt_last, solver.model, solver.opt, step)
+        cur = pde_residual_stats(residual_field)["res_max"]
+        if cur < best:
+            best = cur
+            save_ckpt(cfg.train.ckpt_best, solver.model, solver.opt, step,
+                      extra={"best_res_max": best})
```

```diff
diff --git a/configs/base.yaml b/configs/base.yaml
@@
   log_dir: runs/exp1
+  ckpt_interval: 200
+  ckpt_last: artifacts/exp1/last.ckpt
+  ckpt_best: artifacts/exp1/best.ckpt
+  resume: true
```

---

# 패치 3 — 샘플 문제·데이터 생성 + DVC 파이프라인

**목표:** “바로 돌려서 재현” 가능한 **작은 문제** 제공.

```diff
diff --git a/data/README.md b/data/README.md
new file mode 100644
--- /dev/null
+++ b/data/README.md
@@
+# Sample Problems
+- `toy_ipm_32.npz`: 32^3 격자의 작은 IPM 초기조건/경계조건 샘플.
+- 생성 스크립트: `scripts/gen_toy_ipm.py`
```

```diff
diff --git a/scripts/gen_toy_ipm.py b/scripts/gen_toy_ipm.py
new file mode 100644
--- /dev/null
+++ b/scripts/gen_toy_ipm.py
@@
+import numpy as np, os
+def main(out="data/toy_ipm_32.npz", n=32, seed=0):
+    rng = np.random.default_rng(seed)
+    # 예시: divergence-free 초기 속도 근사 + 간단 경계 조건
+    v = rng.normal(0,1,(3,n,n,n)).astype("float32") * 1e-1
+    bc = np.zeros((3,n,n,n), dtype="float32")
+    np.savez_compressed(out, v0=v, bc=bc, meta=dict(grid=n))
+    print("wrote", out)
+if __name__ == "__main__": main()
```

```diff
diff --git a/dvc.yaml b/dvc.yaml
--- a/dvc.yaml
+++ b/dvc.yaml
@@
 stages:
   gen_toy_ipm:
     cmd: python scripts/gen_toy_ipm.py
     deps:
       - scripts/gen_toy_ipm.py
     outs:
       - data/toy_ipm_32.npz
```

`README.md`(상단)에 DVC 원격 예시를 추가:

````diff
+## Quick Repro (10 min)
+```bash
+pip install dvc
+dvc init
+dvc remote add -d origin s3://<your-bucket>/usd
+dvc repro gen_toy_ipm
+python -m usd.train --config configs/base.yaml
+```
+결과: `runs/exp1/`(TensorBoard), `artifacts/exp1/{last,best}.ckpt`, `metrics.csv`
+```

---

# 패치 4 — 결과 표·그래프 자동 저장(논문식 보고서 초안)

```diff
diff --git a/src/usd/report.py b/src/usd/report.py
new file mode 100644
--- /dev/null
+++ b/src/usd/report.py
@@
+import csv, os
+def append_metrics_csv(path, step, metrics: dict):
+    os.makedirs(os.path.dirname(path), exist_ok=True)
+    hdr = not os.path.exists(path)
+    with open(path, "a", newline="") as f:
+        w = csv.DictWriter(f, fieldnames=["step", *metrics.keys()])
+        if hdr: w.writeheader()
+        w.writerow({"step": step, **metrics})
````

```diff
diff --git a/src/usd/train.py b/src/usd/train.py
@@
-            if writer:
+            if writer:
                 for k,v in log.items(): writer.add_scalar(k, v, step)
                 if scalings is not None and "lambda" in scalings:
                     writer.add_scalar("lambda", float(scalings["lambda"]), step)
+            from usd.report import append_metrics_csv
+            append_metrics_csv("artifacts/exp1/metrics.csv", step, log)
```

---

# 패치 5 — 테스트(핵심 함수 3종) + 샘플 통합 테스트

```diff
diff --git a/tests/test_metrics.py b/tests/test_metrics.py
new file mode 100644
--- /dev/null
+++ b/tests/test_metrics.py
@@
+import torch
+from usd.metrics import pde_residual_stats
+def test_pde_residual_stats_shapes():
+    r = torch.zeros(4,4,4)
+    stats = pde_residual_stats(r)
+    assert set(stats.keys()) == {"res_max","res_l2","res_mean"}
+    assert stats["res_max"] == 0.0
```

```diff
diff --git a/tests/test_repro.py b/tests/test_repro.py
new file mode 100644
--- /dev/null
+++ b/tests/test_repro.py
@@
+from usd.utils.repro import set_global_seed
+import numpy as np
+def test_seed_fix():
+    set_global_seed(123)
+    a = np.random.default_rng(0).normal()
+    b = np.random.default_rng(0).normal()
+    assert a == b  # deterministic within test scope
```

```diff
diff --git a/tests/test_train_dry.py b/tests/test_train_dry.py
new file mode 100644
--- /dev/null
+++ b/tests/test_train_dry.py
@@
+def test_config_loads():
+    # 최소: 설정 로딩과 Trainer 초기화만 검증
+    import yaml
+    with open("configs/base.yaml") as f: cfg = yaml.safe_load(f)
+    assert "train" in cfg and "max_steps" in cfg["train"]
```

---

# 패치 6 — GitHub Actions CI

```diff
diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
new file mode 100644
--- /dev/null
+++ b/.github/workflows/ci.yml
@@
+name: CI
+on: [push, pull_request]
+jobs:
+  test:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - uses: actions/setup-python@v5
+        with: { python-version: '3.10' }
+      - run: pip install -e .[dev]
+      - run: pip install -r requirements.txt || true
+      - run: pytest -q
+  docker-build:
+    runs-on: ubuntu-latest
+    steps:
+      - uses: actions/checkout@v4
+      - run: docker build -t usd:ci .
```

`pyproject.toml`(개발 extras) 예시:

```diff
diff --git a/pyproject.toml b/pyproject.toml
--- a/pyproject.toml
+++ b/pyproject.toml
@@
 [project.optional-dependencies]
 dev = ["pytest", "tensorboard", "ruff", "mypy"]
```

---

# 패치 7 — CLI 엔트리포인트 & Makefile

```diff
diff --git a/pyproject.toml b/pyproject.toml
@@
 [project.scripts]
 usd-train = "usd.train:cli"
 usd-eval  = "usd.eval:cli"
```

```diff
diff --git a/Makefile b/Makefile
new file mode 100644
--- /dev/null
+++ b/Makefile
@@
+.PHONY: quick repro test
+quick:
+	python scripts/gen_toy_ipm.py
+	usd-train --config configs/base.yaml
+repro:
+	dvc repro gen_toy_ipm && usd-train --config configs/base.yaml
+test:
+	pytest -q
```

---

# 패치 8 — README의 “과장” 정리 + 재현 섹션

````diff
diff --git a/README.md b/README.md
--- a/README.md
+++ b/README.md
@@
-### Claims
-- machine precision (~1e-13)
-- 2.3x faster (16 patches)
-- 100% reproducibility
+### Scope
+- 연구용 프로토타입(POC) 구현이며, 아래 “Reproduction” 절차의 **지표**로만 결과를 보고합니다.
+- 성능 수치는 하드웨어/정밀도/격자에 따라 달라질 수 있습니다.
+
+## Reproduction (Toy)
+```bash
+pip install -e .[dev] && pip install dvc tensorboard
+dvc init && dvc repro gen_toy_ipm
+usd-train --config configs/base.yaml
+tensorboard --logdir runs/exp1
+```
+Artifacts: `artifacts/exp1/metrics.csv`, `best.ckpt`, `last.ckpt`
````

---

# 패치 9 — 선택: W&B/MLflow 통합(원하실 때만)

* 환경변수 `WANDB_MODE=offline` 기본, `--log_wandb true`일 때만 활성화.
* 규정상/내부망 이슈 있으면 **CSV + TensorBoard**만 유지해도 충분합니다.

---

# 적용 순서(권장)

1. 패치 1→2를 먼저 적용해 “실행·측정·저장” 파이프를 만듭니다.
2. 패치 3로 **작은 문제**를 제공해 “처음 온 사람”도 10분 내 재현.
3. 패치 5→6으로 신뢰 기초(테스트/CI)를 깝니다.
4. 패치 8로 README 톤 다운 + 재현 지침 명확화.
5. 이후 λ 추정·안정성 분석(고유모드/스펙트럼) 같은 연구 특화 모듈을 확장하세요.

---

# 기대 효과(정량)

* **재현성**: 누구나 `dvc repro` + `usd-train`으로 동일 로그·체크포인트 확보.
* **투명성**: `metrics.csv`/TensorBoard로 잔차 추이와 수렴 정도 시각화.
* **신뢰 신호**: CI 뱃지, 테스트 통과, 도커 빌드 성공 → 외부 기여 유도.
* **릴리즈 준비**: `best.ckpt`/`last.ckpt` + 간단 보고서(표/그래프)로 release 자산화.

---

필요하시면 위 패치를 **PR 템플릿**과 함께 묶어서 첫 PR까지 드롭인 형태로 정리해 드릴게요. 또한 현재 레포 구조를 알려주시면(폴더/모듈 이름) diff를 더 정확히 맞춰서 제공하겠습니다.
