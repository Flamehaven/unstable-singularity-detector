🛠️ Path #1 — Patch Set 1 (3개 개선)
1. Early Stopping (loss/gradient 기준)

📍 파일: gauss_newton_optimizer_enhanced.py

*** Begin Patch
*** Update File: gauss_newton_optimizer_enhanced.py
@@ class HighPrecisionGaussNewtonEnhanced:
-        for epoch in range(self.max_epochs):
+        for epoch in range(self.max_epochs):
+            # Early stopping check
+            if hasattr(self, "early_stop_threshold") and self.early_stop_threshold is not None:
+                if loss.item() < self.early_stop_threshold:
+                    logger.info(f"[Early Stop] Epoch {epoch}: Loss {loss.item():.3e} < threshold {self.early_stop_threshold:.3e}")
+                    break
*** End Patch

2. Stage 1 Checkpoint 저장

📍 파일: multistage_training.py

*** Begin Patch
*** Update File: multistage_training.py
@@ class MultiStageTrainer:
-        history = train_function(
+        history = train_function(
             network=self.stage1_network,
             max_epochs=self.config.stage1_epochs,
             target_loss=self.config.stage1_target_residual,
             checkpoint_freq=self.config.checkpoint_frequency
         )
+
+        # Save checkpoint
+        ckpt_path = f"checkpoint_stage1_final.pt"
+        torch.save({
+            "model_state_dict": self.stage1_network.state_dict(),
+            "history": history
+        }, ckpt_path)
+        logger.info(f"[Checkpoint] Stage 1 model saved at {ckpt_path}")
*** End Patch

3. Adaptive σ 자동 추정 (Residual 기반)

📍 파일: multistage_training.py

*** Begin Patch
*** Update File: multistage_training.py
@@ class MultiStageTrainer:
-        # Stage 2 network (Fourier PINN)
-        sigma = self.config.stage2_fourier_sigma or (2*np.pi*self.analyze_residual_frequency(residual, spatial_grid))
-        self.stage2_network = FourierFeatureNetwork(
-            input_dim=spatial_grid.shape[-1],
-            hidden_dim=64,
-            output_dim=1,
-            fourier_sigma=sigma,
-            num_fourier_features=64
-        ).to(self.device)
+        # Stage 2 network (Fourier PINN) with adaptive σ
+        if self.config.stage2_fourier_sigma is None:
+            dominant_freq = self.analyze_residual_frequency(residual, spatial_grid)
+            sigma = 2 * np.pi * dominant_freq
+            logger.info(f"[Adaptive σ] Using σ = {sigma:.4f} from residual analysis")
+        else:
+            sigma = self.config.stage2_fourier_sigma
+
+        self.stage2_network = FourierFeatureNetwork(
+            input_dim=spatial_grid.shape[-1],
+            hidden_dim=64,
+            output_dim=1,
+            fourier_sigma=sigma,
+            num_fourier_features=64
+        ).to(self.device)
*** End Patch